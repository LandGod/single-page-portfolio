import Highlight from "react-highlight";
import "highlight.js/styles/monokai-sublime.css";

function CodeSample() {
  return (
    <div className="container mx-auto px-36">
      <Highlight className="rounded-sm javascript">
        {`  
    // Index name chosen by Hugo Env (will be either "dev_JBC" or "prod_JBC")
    import {INDEX_NAME, SECTION} from "@params";

    // This is a minimal and lightweight API interface from Algolia.
    import algoliaSearch from "algoliasearch";

    // Minimum time between API request in milliseconds
    // When the user is typing, we will update their search results no more than once per this amount of time.
    const DEBOUNCE_MS = 500;

    // Settings templates
    const optionTemplate = {};
    if (SECTION === "support") {
    optionTemplate.category = "support";
    optionTemplate.numberOfResults = 5;
    }
    class SearchIndex {
    /**
    * SearchIndex
    * ======================================================
    * Sets up a connection to Algolia using our App ID and a front-end safe read-only API key
    * @param {object} defaultOptions - Defaults values for the options passed to this.search. Generally this should be left undefined unless there is a good reason.
    * @param {DOMElement} searchInput - DOM element in which the user will enter their search query.
    * @param {DOMElement} dropdownContainer - DOM element in which results should appear while the user types
    */
    constructor(defaultOptions, searchInput, dropdownContainer) {
        // Note the api key used below is the public "Search API Key". We should never expose our Admin or Write API keys in front-end code.
        // (ApplicationId, ApiKey)
        const client = algoliaSearch(
        "GC4T7B6ED1",
        "7daa4c8b36c451531f5c7e34b9c1dc9b"
        );
        this.index = client.initIndex(INDEX_NAME);
        this.defaultOptions = defaultOptions || {};
        this.searchInput = searchInput || document.getElementById("search-input");
        this.dropdownContainer =
        dropdownContainer || document.getElementById("search-results-dropdown");
    }

    /**
    * Search
    * ======================================================
    * Basically just an alias to the Algolia index search method but with easier to use options
    * @param {string} query - Search parameters. Will be urlEscaped under the hood, so any string should be okay
    * @param {object} options - Object containing additional optional arguments
    *  @param {string} {category} - Specifying a category will limit returned results to only those in the matching category. Must be one of: [products, support, blog, press]
    *  @param {integer} {numberOfResults} - Default: 20 - Integer representing the number of results per "page" to return
    *  @param {integer} {atPage} - Default: 0 - Which set of paginated results to return (zero indexed). If total results does not have that many pages, the results array will be blank
    *
    */
    search(
        query,
        {
        category = this.defaultOptions.category || null,
        numberOfResults = this.defaultOptions.numberOfResults || null,
        atPage = this.defaultOptions.atPage || 0,
        } = {}
    ) {
        const options = {};

        if (category) options.facetFilters = \`section:\${category}\`;
        if (numberOfResults) options.hitsPerPage = numberOfResults;
        if (atPage) options.page = atPage;

        // console.log("Sending search query", {query});

        return this.index.search(query, options);
    }

    /**
    * RenderSingleResult
    * ======================================================
    * Returns a complete single DOM element representing a single search result.
    * Will try to provide the most relevant short text snippet along with title, section, and link.
    * @param {string} title - Title of the page this result references. Equal to calling .Title on the page in Hugo.
    * @param {string} summary - Either the value of .Description or .Summary from Hugo. (Auto-generated by Hugo from .Content if not created by user)
    * @param {object} highlights - Generated by Algolia to give a short snippet targeted at the specific match words
    *  Looks like this: {[content, section,summary,title]:{value: "string snippet", matchLevel: "String. One of: full, partial, none", matchedWords: [strings]}}.
    *  More on highlights: https://www.algolia.com/doc/guides/building-search-ui/going-further/backend-search/in-depth/understanding-the-api-response/#hits
    * @param {string} href - Relative path to the page this search result corresponds to
    * @param {string} section - This is the page "category" equivalent to calling .Section on the page in Hugo. Should be one of: [products, support, blog, press]
    *
    */
    renderSingleResult({
        title,
        summary,
        _highlightResult: highlights,
        href,
        //  section,
    }) {
        // Extract the the most relevant snippet with preference towards "summary" over "content"
        let snippet = summary || "";
        snippet += "...";
        for (const level of ["full", "partial", "none"]) {
        for (const field of ["summary", "content"]) {
            if (
            highlights?.[field]?.value &&
            highlights?.[field]?.matchLevel === level
            ) {
            snippet = highlights.summary.value;
            break;
            }
        }
        }

        snippet = snippet.substring(0, 200);
        if (snippet.length >= 174) snippet += "...";

        // Return HTML element
        return \`
        <div class="rfs:py-2 md:py-3 border-b-4 border-white">
        <a class="block cursor-pointer group" href="\${href}">
            <div class="text-orange-400 rft:text-lg lg:rfs:text-xl group-hover:text-orange-600">
            \${title}
            </div>
            <div class="text-gray-500 hidden md:block rfs:text-sm md:rfs:text-base lg:rfs:text-lg font-light group-hover:text-gray-800">
            \${snippet}
            </div>
        </a>
        </div>
    \`;
    }

    /**
    * RenderResultsDropdown
    * ======================================================
    * Calls renderSingleResult for each entry in the hits array returned by Algolia.
    * Must be given a DOM element which it can put the results into.
    * @param {object} rawQueryResult - Object returned by Algolia from a standard query
    * @param {DOMElement} domRenderContainer - Valid DOM element which child result elements will be inserted into. (Will be cleared of any children every time the function runs.)
    *
    */
    renderResultsDropdown(rawQueryResult, domRenderContainer) {
        // console.log("Raw API response", {rawQueryResult});

        // Error check
        if (!domRenderContainer) {
        console.error(
            "SearchIndex.renderResultsDropdown cannot run because the provided domRenderContainer is missing or invalid."
        );
        }

        // Reveal dropdown
        domRenderContainer.classList.remove("hidden");

        // Get actual list of search hits from results object
        const results = rawQueryResult?.hits;

        // Clear any existing information from dropdown
        domRenderContainer.innerHTML = "";

        // Inform user and skip additional rendering if results list is empty
        if (!results || !results?.length) {
        domRenderContainer.innerHTML = \`
        <div class="rfs:pb-2 border-b-4 border-white">
            No results match this search.
        </div>\`;
        return;
        }

        results.forEach((singleResult) => {
        domRenderContainer.insertAdjacentHTML(
            "beforeend",
            this.renderSingleResult(singleResult)
        );
        });
    }

    /**
    * init
    * ======================================================
    * Sets up event listeners to allow user input to translate into API queries and display results
    * In order to rate limit the API requests, we update the search string in the request every time the user interacts
    * but we only actually send the request every 0.5 seconds (DEBOUNCE_MS).
    *
    * The first user input (at 3 or more characters) triggers an API request instantly, and starts the interval timer.
    * When the currently queued search string is the same as the last search string to be used, the timer is canceled.
    * It can be restarted at any time by further user input.
    *
    * This method does not take any arguments, but there are some important variables:
    * - {timer | boolean} searchQueryDebounce - Contains the pointer to setInterval. Is set to false when the timer is not running, thus allowing bool checks on timer status.
    * - {array} lastRequest - Array of arguments last sent to search function. Use index 0 to get search query string for comparison.
    * - {array} enqueuedRequest - Array of arguments that are queued up to be sent to the search function at the next interval.
    */
    init() {
        // DOM elements
        const searchInput = this.searchInput;
        const searchResultsDropdown = this.dropdownContainer;
        // Used to ensure that request are only sent once and not more than once per half second
        // Note that the request trackers store arrays, so comparison should be done on index 0 (a string)
        let searchQueryDebounce = false;
        let lastRequest = null;
        let enqueuedRequest = null;

        // Listen for typing events in search box
        searchInput.addEventListener("keyup", (event) => {
        // If the user hits enter, redirect to results page instead of updating search suggestions
        if (event.key === "Enter") {
            console.log(
            "[UnImplemented feature]: Redirect to results page at /search/"
            );
            return;
        }

        // If search query is less than 3 letters, don't search
        // Also hide dropdown since deleting the query should trigger a hide
        if (searchInput.value.length < 1) {
            searchResultsDropdown.classList.add("hidden");
            return;
        }

        // Build new search request (destructure into algoliaIndex.search args)
        const requestData = [searchInput.value];

        // If no other searches are enqueued, search immediately, else, replace enqueued request with this one
        // EnqueuedRequest will always be updated. lastRequest will only be updated when an API request is sent.
        if (!searchQueryDebounce) {
            // Make API request immediately
            this.search(...requestData).then((results) => {
            this.renderResultsDropdown(
                results,
                searchResultsDropdown,
                Boolean(searchQueryDebounce)
            );
            });

            // Update both tracking variables to what we just sent
            // lastRequest === enqueuedRequest at this point
            enqueuedRequest = requestData;
            lastRequest = requestData;

            // Spin up interval to do a new API request every half second until the next request would be a duplicate
            searchQueryDebounce = setInterval(() => {
            if (
                !lastRequest ||
                (enqueuedRequest &&
                lastRequest &&
                enqueuedRequest[0] !== lastRequest[0])
            ) {
                // Actual API call via our wrapper around the algoliasearch package where enqueuedRequest is an ordered array of function arguments
                this.search(...enqueuedRequest).then((results) => {
                this.renderResultsDropdown(
                    results,
                    searchResultsDropdown,
                    Boolean(searchQueryDebounce)
                );
                });
                // Update lastRequest so we know what we just did
                lastRequest = enqueuedRequest;
            } else {
                // If the enqueued request is the same as the last request, then we do not make another request
                // and we stop the interval timer. We also set the interval variable to false so we know it's not active anymore next time we check
                clearInterval(searchQueryDebounce);
                searchQueryDebounce = false;
            }
            }, DEBOUNCE_MS);
        } else {
            // If the interval timer is already running, we simply swap in the newest request and leave it to execute on its own timeline.
            enqueuedRequest = requestData;
        }
        });

        // Handle click on and click off for dropdown
        searchInput.addEventListener("focus", () => {
        if (searchInput?.value?.length >= 1) {
            searchResultsDropdown.classList.remove("hidden");
        }
        });

        document.addEventListener("click", (event) => {
        if (searchResultsDropdown.classList.contains("hidden")) return;

        if (
            event.target &&
            !searchInput.contains(event.target) &&
            !searchResultsDropdown.contains(event.target)
        ) {
            searchResultsDropdown.classList.add("hidden");
        }
        });
    }
    }

    // Wait for DOM Content to load, then initialize Algolia Search
    if (
    document.readyState === "complete" ||
    document.readyState === "interactive"
    ) {
    window.algoliaIndex = new SearchIndex(optionTemplate);
    if (window.algoliaIndex.searchInput) {
        window.algoliaIndex.init();
    } else {
        console.info(
        "ðŸ”Ž No search bar detected on page. Search functionality will not be initiated."
        );
    }
    } else {
    window.addEventListener(
        "DOMContentLoaded",
        () => {
        window.algoliaIndex = new SearchIndex(optionTemplate);
        if (window.algoliaIndex.searchInput) {
            window.algoliaIndex.init();
        } else {
            console.info(
            "ðŸ”Ž No search bar detected on page. Search functionality will not be initiated."
            );
        }
        },
        {once: true}
    );
    }

        `}
      </Highlight>
    </div>
  );
}

export default CodeSample;
